#include "Header1.h"

List::List() {
	head = nullptr;
	tail = nullptr;
	size = 0;
}

// Метод для добавления нового элемента в список
void List::insert(std::string surname, int tabelNum, std::string departmentName, double salary) {
	Node* newNode = new Node;
	newNode->surname = surname;
	newNode->tabelNum = tabelNum;
	newNode->departmentName = departmentName;
	newNode->salary = salary;
	newNode->next = nullptr;
	newNode->prev = nullptr;

	if (head == nullptr) {
		head = newNode;
		tail = newNode;
	}
	else {
		tail->next = newNode;
		newNode->prev = tail;
		tail = newNode;
	}
}

// Функция для преобразования символа в нижний регистр
char toLower(char c) {
	if (c >= 'A' && c <= 'Z') {
		return c + 32; // Разница между 'A' и 'a' равна 32 в ASCII
	}
	return c; // Возвращаем тот же символ, если это не заглавная буква
}

// Функция для сравнения строк без учета регистра
bool isEqualIgnoreCase(const std::string& str1, const std::string& str2) {
	if (str1.size() != str2.size()) {
		return false;
	}
	for (size_t i = 0; i < str1.size(); ++i) {
		if (toLower(str1[i]) != toLower(str2[i])) {
			return false;
		}
	}
	return true;
}

// Метод для удаления элемента из списка по фамилии
void List::removeSurname(std::string surname) {
	Node* current = head;
	bool found = false; // Флаг для указания на успешное удаление
	while (current != nullptr) {
		if (isEqualIgnoreCase(current->surname, surname)) {
			found = true; // Установка флага, если фамилия найдена
			if (current == head) {
				head = current->next;
			}
			else if (current == head and current == tail) {
				head = nullptr;
				tail = nullptr;
			}
			else if (current == tail) {
				tail = current->prev;
				tail->next = nullptr;
			}
			else {
				current->prev->next = current->next;
				current->next->prev = current->prev;
			}
			delete current;
			break;
		}
		current = current->next;
	}
	if (!found) {
		std::cout << "\nФамилии " << surname << " нет в списке." << std::endl;
	}
}

// Метод для проверки наличия фамилии в списке
bool List::containsSurname(const std::string& surname) {
	Node* current = head;
	while (current != nullptr) {
		if (current->surname == surname) {
			return true;
		}
		current = current->next;
	}
	return false;
}

// Функция для вывода списка в прямом порядке
void List::print() {
	if (head == nullptr) {
		std::cout << "\nСписок пуст." << std::endl;
		return;
	}

	Node* current = head;
	std::cout << "\n";
	while (current != nullptr) {
		std::cout << "-------------------------------------\n";
		std::cout << "Фамилия: " << current->surname << "\n"
			<< "Зарплата: " << current->salary << "\n"
			<< "Название цеха: " << current->departmentName << "\n"
			<< "Табельный номер: " << current->tabelNum << "\n\n";
		current = current->next;
	}
}

// Функция для вывода списка в обратном порядке
void List::printReverse() {
	if (head == nullptr) {
		std::cout << "\nСписок пуст." << std::endl;
		return;
	}

	Node* current = tail;
	std::cout << "\n";
	while (current != nullptr) {
		std::cout << "-------------------------------------\n";
		std::cout << "Фамилия: " << current->surname << "\n"
			<< "Зарплата: " << current->salary << "\n"
			<< "Название цеха: " << current->departmentName << "\n"
			<< "Табельный номер: " << current->tabelNum << "\n\n";
		current = current->prev; // Переход к предыдущему элементу
	}
}

//Сортировка по зарплате
void List::sortSalary() {
	Node* current = head;
	while (current != nullptr) {
		Node* temp = current->next;
		while (temp != nullptr) {
			if (current->salary > temp->salary) {
				std::swap(current->surname, temp->surname);
				std::swap(current->tabelNum, temp->tabelNum);
				std::swap(current->departmentName, temp->departmentName);
				std::swap(current->salary, temp->salary);
			}
			temp = temp->next;
		}
		current = current->next;
	}

	std::cout << "\nОтсортированный список по уровню зарплаты:\n";
	std::cout << "------------------------------------------\n";

	Node* cur = head;
	while (cur) {
		std::cout << "Фамилия: " << cur->surname << ", "
			<< "Зарплата: " << cur->salary << ", "
			<< "Название цеха: " << cur->departmentName << ", "
			<< "Табельный номер: " << cur->tabelNum << std::endl;
		cur = cur->next;
	}
}

// Метод для считывания данных из файла
void List::readFromFile(std::string fileName) {
	std::ifstream file(fileName);
	std::string surname;
	int tabelNum;
	std::string departmentName;
	double salary;
	while (file >> surname >> tabelNum >> departmentName >> salary) {
		insert(surname, tabelNum, departmentName, salary);
	}
	std::cout << "\nДанные успешно считаны из файла. " << std::endl;
	file.close();
}

// Метод для записи данных в файл
void List::writeToFile(std::string fileName) {
	std::ofstream file(fileName);
	Node* current = head;
	while (current != nullptr) {
		file << current->surname << " " << current->tabelNum << " " << current->departmentName << " " << current->salary << std::endl;
		current = current->next;
	}
	std::cout << "\nДанные успешно записаны в файл." << std::endl;
	file.close();
}

// Деструктор для освобождения памяти, выделенной под элементы списка
List::~List() {
	Node* current = head;
	while (current != nullptr) {
		Node* temp = current;
		current = current->next;
		delete temp;
	}
}

// Метод для вывода всех трат на определенный цех
void List::allPayments(std::string departmentName) {
	Node* current = head;
	double sum = 0;
	while (current) {
		if (current->departmentName == departmentName) {
			sum += current->salary;	
		}
		current = current->next;
	}
	std::cout << "\nВсе траты на " << departmentName << " - " << sum << std::endl;
}

// Метод для вывода средней зарплаты работников определенного цеха
void List::averagePayment(std::string departmentName) {
	Node* current = head;
	double sum = 0;
	int count = 0;
	while (current) {
		if (current->departmentName == departmentName) {
			sum += current->salary;
			count++;
		}
		current = current->next;
	}
	std::cout << "\nСредняя зарплата работника " << departmentName << " - " << sum / count << std::endl;
}

// Метод для вывода ведомости по определенному цеху
void List::statement(std::string departmentName) {
	Node* current = head;

	while (current) {
		if (current->departmentName == departmentName) {
			std::cout << "\nВедомость по отделу " << departmentName << ":\n";
			std::cout << "-------------------------------------\n";
			std::cout << "Фамилия: " << current->surname << "\n";
			std::cout << "Зарплата: " << current->salary << " рублей.\n";
			std::cout << "-------------------------------------\n";
		}

		Node* temp = current->next;
		while (temp) {
			if (current->surname > temp->surname) {
				std::swap(current->surname, temp->surname);
				std::swap(current->tabelNum, temp->tabelNum);
				std::swap(current->departmentName, temp->departmentName);
				std::swap(current->salary, temp->salary);
			}
			temp = temp->next;
		}
		current = current->next;
	}
}

// Метод для поиска по фамилии
void List::searchBySurname(std::string surname) {
	Node* current = head;

	while (current) {
		if (current->surname == surname) {
			std::cout << "Фамилия: " << current->surname << std::endl;
			std::cout << "Табельный номер: " << current->tabelNum << std::endl;
			std::cout << "Название цеха: " << current->departmentName << std::endl;
			std::cout << "Зарплата: " << current->salary << std::endl;
			std::cout << "-------------------------------------" << std::endl;
		}
		current = current->next;
	}
}

// Метод для проверки наличия цеха в списке
bool List::containsDepartment(const std::string& departmentName) {
	Node* current = head;
	while (current != nullptr) {
		if (current->departmentName == departmentName) {
			return true;
		}
		current = current->next;
	}
	return false;
}

// Сортировка по фамилии
void List::sortSurname() {
	Node* current = head;
	while (current != nullptr) {
		Node* temp = current->next;
		while (temp != nullptr) {
			if (current->surname > temp->surname) {
				std::swap(current->surname, temp->surname);
				std::swap(current->tabelNum, temp->tabelNum);
				std::swap(current->departmentName, temp->departmentName);
				std::swap(current->salary, temp->salary);
			}
			temp = temp->next;
		}
		current = current->next;
	}
	std::cout << "\nОтсортированный список по фамилии: " << std::endl;

	Node* cur = head;
	while (cur) {
		std::cout << "Фамилия: " << cur->surname << ", зарплата: " << cur->salary << ", название цеха: " << cur->departmentName << ", табельный номер: " << cur->tabelNum << std::endl;
		cur = cur->next;
	}
	
}


